# PEP-9: Implementing Authorization of the IAM Model
- Author(s): Mark Servilla, Roger Dahl
- Contact: mark.servilla@gmail.com
- Status: Draft
- Type: Application
- Created: 2024-11-24
- Reviewed:
- Final:


## Introduction

Protecting digital resources through access control is paramount to the EDI Identity and Access Management (IAM) model (see [PEP-7](./pep-7.md)). Digital resources in the EDI ecosystem can be anything, inlcuding the elements of a data package (e.g., metadata, quality report, or data), web-service API methods, the scope values of data package identifiers, web-application actions (e.g., forms or links), or metadata models created and edited in *ezEML*. These resources require protection from malicious and non-malicious actions through the use of access control rules (ACRs), which codify how a user of an EDI application may act upon a resource.

The following PEP proposes the development of an *authorization service* that unifies access control across all EDI applications. It will improve application scalability and eliminate idiosyncratic access control behavior of "stove-pipe" solutions. A single *authorization service* will greatly improve EDI's IAM model in three ways:

1. It will provide an ecosystem-wide, centralized service with a standard interface available for use by all EDI applications to manage access control rules.
2. It will use *PASTA IDs* ([see PEP-2](./pep-2.md)) generated by the EDI *authentication service* in lieu of IdP identifiers (which border on  personally identifiable information).
3. It will allow access control rules for resources to be created and modified at any time.

## Background 

Historically, access control for EDI revolved around the core repository, PASTA, where static access control rules, codified in user-provided [Ecological Metadata Language](https://eml.ecoinformatics.org) (EML) metadata documents, dictated who may read and update the science metadata and data of a data package. These ACRs are declared using the [`<access>`](https://eml.ecoinformatics.org/schema/eml_xsd#eml_access) element (Figure 1) of the EML XML schema (multiple rules can be defined within a single `<access>` element, creating an access control list (ACL)).

![](./images/pep9-EML_access_element.png)<!--{ width=65% }-->

**Figure 1:** XML schema diagram for an Ecological Metadata Language `<access>` element.

For an EML `<access>` element (see example in Listing 1), the access control rule can either "allow" or "deny" access to the data package's resources (the specific resource in question depends on where in the document the rule is defined). The type of access enforced by the rule is defined by `<access>` sub-elements `<allow>` and `<deny>` (although a "deny" action is permitted to explicitly revoke a privilege on a resource, it is rarely used in practice). Within an `<allow>` or `<deny>` element, the subject and privilege of the ACR is defined by the `<principal>` and `<permission>` sub-elements. For EDI, the value of the `<principal>` element can be any string but generally consists of the unique identity assigned to a user by an Identity Provider (IdP) or is an arbitrary group identifier (e.g., "authenticated"). In contrast, the value of the `<permission>` element can only be one of the following:

* **read** (to gain immutable "read" access to a resource),
* **write** (to gain mutable "create", "read" , "update", and "delete" access to a resource), or
* **changePermission** (to everything in *write*, along with the privilege to alter other's access to a resource).

(These specific permissions are not part of the EML `<access>` element schema; they are legacy and were defined by the Long Term Ecological Research (LTER) Network information management community.)

```xml
<access>
  <allow>
    <principal>uid=mark,o=EDI,dc=edirepository,dc=org</principal>
    <permission>read</permission>
  </allow>
</access>
```
**Listing 1:** Example definition of an Ecological Metadata Language `<access>` element. If found in metadata describing data in a file named `table.csv`, this ACR can be read informally as "the user, `uid=mark,o=EDI,dc=edirepository,dc=org`, *is allowed permission to read* the data contained within `table.csv`."

> *Side note*: An `<access>` element ACR may be read as an [RDF triple](https://www.w3.org/TR/rdf11-concepts/#section-triples) **<subject, predicate, object>**, where the *principal* in the ACR is the **subject**, the combination of either "allow" or "deny", along with the *permission*, is the **predicate**, and the protected resource is the **object** .

ACLs for PASTA API methods are declared in a standalone XML document file, `service.xml`, one each for the Data Package Manager (DPM) and Audit Manager (AM) services. These ACLs are read into the system during the PASTA bootstrap process and can be changed by editing the file and restarting the system.

ACLs for data package resources are declared in the data package's EML metadata document and are translated from XML and stored in the `access_matrix` RDBS table as single ACRs when the data package EML is first uploaded into the repository; these ACRs cannot be modified once they are entered into the table. Data package ACLs can occur at two levels: (1) at the "data package" level, which sets the permissions for all data package resources (i.e., metadata, quality report, and data entities) and (2) at the "data entity" level, which sets permissions for individual data entities and overides permissions set at the "data package" level (it is not uncommon to set "public" read access to the metadata and quality report, but restrict "public" access to data entities).

Both the `service.xml` file and EML metadata use the same XML `<access>` element structure, allowing use of the same ACR processor to determine authorization. In both cases, ACRs allowing access to resources must be explicitly granted, otherwise the resource request is denied.

For ezEML, there is an implicit **write** permission for the owner of a resource. In this case, the owner is identified through the IdP identifier provided through the PASTA authentication token. Resources are held in filesystem directories that map to the owner's identifier and only the owner of the directory may create or modify resources within it. There is exception to this rule where the owner of the resource may grant temporary **write** access to another user of ezEML, enabling collaboration. This process, however, does not provide permanent access to the resource and is revoked when the proxy user completes their actions.

## Issue Statement

The current use of access management within EDI applications has the following issues:

1. Applications within the EDI ecosystem are faced with designing and implementing access management processing in isolation. This leads to idiosyncratic, non-interoperable solutions for a customer base that transcends all EDI applications, resulting in confusion and, at worse, security breaches.
2. IdP user identifiers and group identifiers are embedded in existing ACRs, which are visible to the public by reviewing the data package XML metadata. This can disclose private or sensitive information, including names, email addresses, and alternative identifiers (e.g., Orcid identifiers). These identifiers also become a permanent record in the EDI data repository audit log, which is another potential exposure of sensitive information.
3. Existing ACRs used in most EDI applications, especially those used for data package resources, are static and immutable once defined. Access control for resources should be dynamic so administrators and users alike can easily create new ACRs, as well as modify and update existing ACRs. In practice, this would allow a resource owner to add (or remove) access to the resource for a user during the life-time of the resource, not just when the resource is created.

## Proposed Solution

We propose to design and implement an *authorization service* that will perform access management for all types of resources used within EDI applications (Figure 2). Because this service shares related content with the authentication service, both services will be combined and operate on the same server using the same Python FastAPI web framework and Postgresql database.

This service will be responsible for the following:

1. Implement a secure and verifiable authorization algorithm that will process ACRs for EDI resources.
2. Support all applications and their respective resources in the EDI ecosystem.
3. Maintain a secure and private ACR registry with the necessary attributes to perform authorization based on #1.
4. Provide a REST API for managing ACRs, including the ability to add, modify, and delete ACRs by users who have "changePermission" privileges to the resource (i.e., an owner of the resource).
5. Provide a web browser UI frontend for managing ACRs for both EDI administrators and users.

![](./images/pep9-EDI_app_ecosystem.png)<!--{ width=50% }-->

**Figure 2:** Proposed EDI application ecosystem with the addition of an authorization service.

### Access Control Rule Registry

The ACR registry will be implemented as RDBMS tables with the following schema (Figure 3):

![](images/pep9-acl-tables.png)

**Figure 3:** Authorization service ACR registry table schema.

The ACR Registry will store ACRs for all applications in the EDI ecosystem. We will use a structure with *collections*, *resources*, and *permissions*. A collection contains zero to many resources, and a resource contains zero to many permissions. Each permission provides *read*, *write* or *chanagePermission* privileges to the principal associated with the ACR. The principal references either a user profile or a group. (A user profile can be a regular user or a system level user, such as the "public" user; both regular users and system users will have a unique PASTA-ID.)

#### Collection

- `id` - An auto-incrementing integer that uniquely identifies each table row.
- `collection.label` - A human-readable name to display for the collection.
- `collection.type` - A string that describes the type of the collection.
- `collection.created_date` - The date and time the collection was created.

#### Resource

- `resource.collection_id` - A reference to the collection to which the resource belongs.
- `resource.key` - A unique system identifier for the resource.
- `resource.label` - A human-readable name for the resource.
- `resource.type` - The resource type.
- `resource.created_date` - The date and time the resource was created.

#### Permission

- `permission.resource_id` - A reference to the resource to which the permission applies.
- `permission.principal_id` - A reference to the user profile or group to which the permission is granted.
- `permission.principal_type` - The principal class (enum of `PROFILE` or `GROUP`) of the permission.
- `permission.level` - The access level granted by this permission (enum of `read`, `write` or `changePermission`).
- `permission.granted_date` - The grant date and time of the permission.

For example, if we are tracking permissions for a data package with metadata and data entities, the `collection.label` might be `knb-lter-bes.1234.5`, and the `collection.type` would be `package`. Linked to this collection would be a number of resources. Each resource would have a `resource.collection_id` referencing the `knb-lter-bes.1234.5` collection. The `resource.label` might be `water.csv` while the `resource.key` would be the PASTA URI `https://pasta.lternet.edu/package/data/eml/knb-lter-bes.1234.5/3fb3ef2e559fa42956b69226e9069058`. The `resource.type` would be `data`. Permissions would then be linked to these resources via `permission.resource_id`. Each permission would have a `permission.principal_id` of a user profile or user group, and a `permission.principal_type` of either `PROFILE` or `GROUP`. The `permission.level` would specify the level of access granted to the principal, and would be `read`, `write` or `changePermission`.


### Authorization algorithm

Premises:

1. All principals are denied access to all resources unless an ACR exists that explicitly grants access for the principal to the resource.
2. An ACR will only support "allow" access to resources; "deny" access will not be supported.
3. If multiple ACRs exist pertaining to the same principal and the same resource, but with different permissions, then the most permissive permission will be granted. (For example, if one ACR allows read access and another allows write access, the write access is applied. Similarly, if one ACR allows read access for a user and another allows write access for a group to which the user belongs, then write access is applied.)

The authorization algorithm requires three parameters:

1. The resource identifier to be accessed.
2. The set of principals (either a user profile or groups) attempting to access the resource (as determined from the authentication token).
3. The requested permission for the resource (*read*, *write*, *changePermission*).

The algorithm is as follows:
```python
def is_authorized(resource, principals, permission) -> bool:
    authorized = False
    acl = getACL(resource)
    for principal in principals:
        for acr in acl:
            if acr.principal == principal:
                if acr.permission <= permission:
                    authorized = True
    return authorized
```
### PASTA Integration

There are three primary integration points between the *authorization service* and PASTA:

1. Data package resource ACR registration ([see UML here](./images/pep9-data_package_resource_add_ACL-Data_Package_Life_Cycle_Authorization.png)).
2. Service method authorization ([see UML here](./images/pep9-service_method_authZ-Service_Method_Authorization.png)).
3. Data package resource authorization ([see UML here](./images/pep9-data_resource_authZ-Read_Resource_Authorization.png)).

Each integration point is selected to minimize the impact on the existing PASTA architecture and to provide a seamless transition to the new *authorization service*.

### Use Case and REST API Method Definitions

**1. Add EML**

Goal: To parse a valid EML document and add its ACRs to the ACR registry for the resources identified in the EML document.

Use case:

1. A client sends and EML document to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* parses the EML and extracts the ACRs.
4. The *authorization service* adds the ACL ACRs to the ACR registry.
5. The *authorization service* returns a success message to client.

Notes: This use case supports the existing PASTA data package upload process. Parsing and extracting ACRs from the EML document will require supporting ACRs in both the main EML document and the additional metadata section. The principal owner of the data package is not currently represented in the existing `access_matrix`. This should, however, change for consistency: the principal owner should be added into the ACR registry with the "changePermission" permission. This method should create a "Data Package" collection.

```
POST /auth/v1/eml

addEML(principal, eml)
    principal: The owner of the data package (may be either a PASTA-ID or an IdP identifier)
    eml: valid EML document as a string
    return:
        200 OK if successful
        400 Bad Request if EML is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method
    body:
        Empty if 200, error message otherwise
    permissions:
        pasta: changePermission
```

**2. Add Access**

Goal: To parse a valid `<access>` element and add its ACRs to the *authorization service* ACR registry.

Use case:

1. A client sends an `<access>` element ACL to the *authorization service* to register ACRs.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* parses the `<access>` element ACL and extracts the ACRs.
4. The *authorization service* adds the ACL ACRs to the ACR registry.
5. The *authorization service* returns a success message to the client.

Notes: This use case supports adding ACLs for PASTA API methods through the `service.xml` file. In this case, the `service.xml` file is not a complete EML document; they consist of ACLs in the form of `<access>` elements. The principal owner of the service method (or other resource) should be added into the ACR registry with the "changePermission" permission; in the case of service methods, the principal owner will be "pasta."

```
POST: /auth/v1/access

addAccess(resource_key, access):
    resource_key: resource key for the <access> element
    access: valid <access> element
    return:
        200 OK if successful
        400 Bad Request if <access> element is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method
    body:
        Empty if 200, error message otherwise
    permissions:
        pasta: changePermission
```

**3a. Create Collection**

Goal: To create a collection

Use case:

1. A client sends a collection to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the collection.
4. The *authorization service* creates the collection.
5. The *authorization service* returns a success message to the client.

```
POST: /auth/v1/collection

createCollection(collection_label, collection_type)
    collection_label: the human readable name of the collection
    collection_type: the type of collection
    return:
        200 OK if successful
        400 Bad Request if collection is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access collection
        404 If PUT or DELETE and the collection is not found
    body:
        The collection_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**3b. Update Collection**

Goal: To update a collection

Use case:

1. A client sends a collection to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the collection.
4. The *authorization service* updates the collection.
5. The *authorization service* returns a success message to the client.

```
PUT: /auth/v1/collection/id

updateCollection(collection_id, collection_label, collection_type)
    collection_id: the unique collection identifier
    collection_label: the human readable name of the collection
    collection_type: the type of collection
    return:
        200 OK if successful
        400 Bad Request if collection is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access collection
        404 If PUT or DELETE and the collection is not found
    body:
        The collection_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**3c. Delete Collection**

Goal: To delete a collection

Use case:

1. A client sends a collection identifier to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the collection.
4. The *authorization service* deletes the collection.
5. The *authorization service* returns a success message to the client.

```
DELETE: /auth/v1/collection/id

deleteCollection(collection_id)
    collection_id: the unique collection identifier
    return:
        200 OK if successful
        400 Bad Request if collection is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access collection
        404 If PUT or DELETE and the collection is not found
    body:
        The collection_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**3d. Read Collection**

Goal: To read a collection

Use case:

1. A client sends a collection identifier to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the collection.
4. The *authorization service* reads the collection information into a structure.
5. The *authorization service* returns a success message to the client.

```
GET: /auth/v1/collection/id

readCollection(collection_id)
    collection_id: the unique collection identifier
    return:
        200 OK if successful
        400 Bad Request if collection is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access collection
        404 If PUT or DELETE and the collection is not found
    body:
        The collection structure if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**4a. Create Resource**

Goal: To create, update, or delete a resource

Use case:

1. A client sends a resource to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the resource.
4. The *authorization service*:
    a. POST: creates the resource
    b. PUT: updates the resource
    c. DELETE: deletes the resource
5. The *authorization service* returns a success message to the client.

```
setResource(resource_key, resource_label, resource_type, collection_id)
    resource_key: the unique resource key of the resource
    resource_label: the human readable name of the resource
    resource_type: the type of resource
    collection_id: the collection identifier (may be `None`)
    return:
        200 OK if successful
        400 Bad Request if resource is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access resource
        404 If PUT or DELETE and the resource is not found
    body:
        The resource_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**4a. Create Resource**

Goal: To create, update, or delete a resource

Use case:

1. A client sends a resource to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the resource.
4. The *authorization service*:
    a. POST: creates the resource
    b. PUT: updates the resource
    c. DELETE: deletes the resource
5. The *authorization service* returns a success message to the client.

```
setResource(resource_key, resource_label, resource_type, collection_id)
    resource_key: the unique resource key of the resource
    resource_label: the human readable name of the resource
    resource_type: the type of resource
    collection_id: the collection identifier (may be `None`)
    return:
        200 OK if successful
        400 Bad Request if resource is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access resource
        404 If PUT or DELETE and the resource is not found
    body:
        The resource_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**4a. Create Resource**

Goal: To create, update, or delete a resource

Use case:

1. A client sends a resource to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the resource.
4. The *authorization service*:
    a. POST: creates the resource
    b. PUT: updates the resource
    c. DELETE: deletes the resource
5. The *authorization service* returns a success message to the client.

```
setResource(resource_key, resource_label, resource_type, collection_id)
    resource_key: the unique resource key of the resource
    resource_label: the human readable name of the resource
    resource_type: the type of resource
    collection_id: the collection identifier (may be `None`)
    return:
        200 OK if successful
        400 Bad Request if resource is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access resource
        404 If PUT or DELETE and the resource is not found
    body:
        The resource_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**4a. Create Resource**

Goal: To create, update, or delete a resource

Use case:

1. A client sends a resource to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the resource.
4. The *authorization service*:
    a. POST: creates the resource
    b. PUT: updates the resource
    c. DELETE: deletes the resource
5. The *authorization service* returns a success message to the client.

```
setResource(resource_key, resource_label, resource_type, collection_id)
    resource_key: the unique resource key of the resource
    resource_label: the human readable name of the resource
    resource_type: the type of resource
    collection_id: the collection identifier (may be `None`)
    return:
        200 OK if successful
        400 Bad Request if resource is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access resource
        404 If PUT or DELETE and the resource is not found
    body:
        The resource_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**5. Create Rule**

Goal: To create, update, or delete an ACR

Use case:

1. A client sends an ACR to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the ACR, if the ACR exists.
4. The *authorization service*:
    a. POST: creates the ACR
    b. PUT: updates the ACR
    c. DELETE: deletes the ACR
5. The *authorization service* returns a success message to the client.

Notes: This use case supports managing an individual ACR for applications that do not use EML or `<access>` elements. The *authorization service* will create a user profile (along with a PASTA-ID) if the principal is not a PASTA-ID.

```
setACR(resource_key, principal, principal_type, permission)
    resource_key: the unique resource key of the resource
    principal: the principal of the ACR
    principal_type: the type of principal (PROFILE or GROUP)
    permission: the permission of the ACR (may be `None` if DELETE)
    return:
        200 OK if successful
        400 Bad Request if ACR is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access ACR
        404 If PUT or DELETE and the ACR is not found
    body:
        The permission_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**5. Create Rule**

Goal: To create, update, or delete an ACR

Use case:

1. A client sends an ACR to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the ACR, if the ACR exists.
4. The *authorization service*:
    a. POST: creates the ACR
    b. PUT: updates the ACR
    c. DELETE: deletes the ACR
5. The *authorization service* returns a success message to the client.

Notes: This use case supports managing an individual ACR for applications that do not use EML or `<access>` elements. The *authorization service* will create a user profile (along with a PASTA-ID) if the principal is not a PASTA-ID.

```
setACR(resource_key, principal, principal_type, permission)
    resource_key: the unique resource key of the resource
    principal: the principal of the ACR
    principal_type: the type of principal (PROFILE or GROUP)
    permission: the permission of the ACR (may be `None` if DELETE)
    return:
        200 OK if successful
        400 Bad Request if ACR is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access ACR
        404 If PUT or DELETE and the ACR is not found
    body:
        The permission_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**5. Create Rule**

Goal: To create, update, or delete an ACR

Use case:

1. A client sends an ACR to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the ACR, if the ACR exists.
4. The *authorization service*:
    a. POST: creates the ACR
    b. PUT: updates the ACR
    c. DELETE: deletes the ACR
5. The *authorization service* returns a success message to the client.

Notes: This use case supports managing an individual ACR for applications that do not use EML or `<access>` elements. The *authorization service* will create a user profile (along with a PASTA-ID) if the principal is not a PASTA-ID.

```
setACR(resource_key, principal, principal_type, permission)
    resource_key: the unique resource key of the resource
    principal: the principal of the ACR
    principal_type: the type of principal (PROFILE or GROUP)
    permission: the permission of the ACR (may be `None` if DELETE)
    return:
        200 OK if successful
        400 Bad Request if ACR is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access ACR
        404 If PUT or DELETE and the ACR is not found
    body:
        The permission_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**5. Create Rule**

Goal: To create, update, or delete an ACR

Use case:

1. A client sends an ACR to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* verifies that the requesting principal is authorized to access the ACR, if the ACR exists.
4. The *authorization service*:
    a. POST: creates the ACR
    b. PUT: updates the ACR
    c. DELETE: deletes the ACR
5. The *authorization service* returns a success message to the client.

Notes: This use case supports managing an individual ACR for applications that do not use EML or `<access>` elements. The *authorization service* will create a user profile (along with a PASTA-ID) if the principal is not a PASTA-ID.

```
setACR(resource_key, principal, principal_type, permission)
    resource_key: the unique resource key of the resource
    principal: the principal of the ACR
    principal_type: the type of principal (PROFILE or GROUP)
    permission: the permission of the ACR (may be `None` if DELETE)
    return:
        200 OK if successful
        400 Bad Request if ACR is invalid
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access ACR
        404 If PUT or DELETE and the ACR is not found
    body:
        The permission_id if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**6a. Get ACL**

Goal: To return the ACL from the *authorization service* ACR registry for a resource key.

Use case:

2. The client sends the resource key to The *authorization service*.
3. The *authorization service* verifies that the requesting principal is authorized to execute the method.
4. The *authorization service* verifies that the requesting principal is authorized to access the ACL.
5. The *authorization service* returns a succes message to the client with the ACL in the body of the response.

Notes: None

```
GET: /auth/resource/key

getACL(resource_key)
    resource_key: the unique resource key
    return:
        200 OK if successful
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access to the resource
        404 If no ACRs are found
    body:
        ACL if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**6a. Get ACL**

Goal: To return the ACL from the *authorization service* ACR registry for a resource identifier.

Use case:

2. The client sends the resource key to The *authorization service*.
3. The *authorization service* verifies that the requesting principal is authorized to execute the method.
4. The *authorization service* verifies that the requesting principal is authorized to access the ACL.
5. The *authorization service* returns a succes message to the client with the ACL in the body of the response.

Notes: None

```
GET: /auth/resource/id

getACL(resource_key)
    resource_key: the unique resource key
    return:
        200 OK if successful
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access to the resource
        404 If no ACRs are found
    body:
        ACL if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**7a. Is Authorized**

Goal: To determine if a principal is authorized to access a resource.

Use case:

1. A client sends an authentication token, the resource key, and the requested permission to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* processes the request and returns a success message if the principal is authorized.

```
POST: /auth/v1/authorized

isAuthorized(token, resource_key, permission)
    token: a valid authentication token
    resource_key: the unique resource key
    permission: the permission being requested
    return:
        200 OK if authorized
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access the resource or if principal is not authorized to access the resource
        404 If the resource_key is not found
    body:
        Empty if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**7b. Is Authorized**

Goal: To determine if a principal is authorized to access a resource.

Use case:

1. A client sends an authentication token, the resource key, and the requested permission to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* processes the request and returns a success message if the principal is authorized.

```
POST: /auth/v1/authorized

isAuthorized(token, resource_id, permission)
    token: a valid authentication token
    resource_id: the unique resource identifier
    permission: the permission being requested
    return:
        200 OK if authorized
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method or access the resource or if principal is not authorized to access the resource
        404 If the resource_key is not found
    body:
        Empty if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

**8. Get Resources**

Goal: Return a list of resource keys owned by the principal.

Use case:

1. A client sends an authentication token to the *authorization service*.
2. The *authorization service* verifies that the requesting principal is authorized to execute the method.
3. The *authorization service* returns a success message if the user is authorized with the list of resource keys and resource labels in the body of the response.

Notes: This use case supports the authorization process for PASTA API methods if the ACLs in the  `service.xml` file are not registered in the *authorization service* ACR registry.

```
GET: /auth/resources

getResources(token)
    token: a valid authentication token
    return:
        200 OK if authorized
        401 Unauthorized if the client does not provide a valid authentication token
        403 Forbidden if client is not authorized to execute method
        404 If no resources are found
    body:
        Resource list if 200, error message otherwise
    permissions:
        authenticated: changePermission
```

### Implementation Strategy for PASTA

The *authorization service* service must integrate seamlessly into PASTA's current authorization workflow. Three separate tasks must be addressed: (1) Service method ACRs for both the DPM and AM services must be migrated to the *authorization service* ACR registry; (2) the existing `access_matrix` database table, including principal owners stored in the DPM `resource_registry` database table, must be migrated to the *authorization service* ACR registry with PASTA IDs; and (3) the DPM service must be modified to use the REST API methods of the *authorization service* service (above) in lieu of its internal authorization processing.

#### Principal Owner and Access Matrix Migration for Data Package Resources

For each data package, an entry in the *authorization service* ACR registry for every data package resource, including the data package itself, will be required for the principal owner. This should be followed by migrating corresponding entries of each data package resource found in the `access_matrix` database table to the *authorization service* ACR registry. (Note that data packages that are not represented in the `access_matrix` imply a full embargo of the data package exists and all access privileges, other than for the owner, are denied.)

1. An *authorization service* `access_matrix` database table (see The *authorization service* Access Control Rule Registry [above](https://github.com/PASTAplus/PEP/blob/main/peps/pep-9.md#authz-access-control-rule-registry)).
2. 


#### Updating the Data Package Manager Service


## Open issue(s)

### 1. Will the *authorization service* support "deny" verbs in ACRs?

Because the "deny" verb is rarely used in practice, it will not be supported in the initial implementation of the *authorization service* service. However, this feature may be added in a future release.

### 2. How will the current `DataPackageManager.access_matrix` table be migrated to the *authorization service* ACR registry?

### 3. How will ezEML interact with the *authorization service* service?

### 4. Will the data package "principal" owner be represented in the ACR registry?

Currently, the data package owner is passed to the "isAuthorized" method through a separate parameter, `principalOwner`, which is obtained by querying the data package manager resource registry. The `principalOwner` is compared to the submitter of the resource access request to determine if the submitter is the owner of the data package, and if so, the submitter is granted "changePermission" access to the data resource in question without the need for an ACR. This is an implicit ACR that is not stored in the ACR registry.

### 5. How will legacy `<access>` elements that contain IdP user identifiers and group identifiers work within the *authorization service* service?

### 6. Should the *authorization service* expose a UI for managing ACRs or should each client application provide its own UI?

## References

...

## Rejection

...
